<!DOCTYPE html>
<html lang="en">
  <head>
    <title>GEODUDE WORKSPACE</title>
    <meta charset="utf-8" />
    <meta
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
      name="viewport"
    />
    <link href="main.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div
      id="title"
      style="
        font-size: 40px;
        color: #1b1b1b;
        margin-top: 20px;
        font-weight: 600;
      "
    >
      GEOTHRERMAL DORM SYSTEM
    </div>

    <div class="container default" id="popup">
      <div class="popMain">
        <img id="popImg" src="Img/Home.JPG" />
        <h1 id="popHeader">Geothermal System</h1>
        <p id="popText" style="font-size: 15px">
          Welcome to our animated model of a Geothermal System!
        </p>
      </div>
    </div>

    <div class="names">
      Scott Comeaux, Logan Freeman, Joeseph Gomez, Jordan Martin
    </div>

    <style>
      body {
        margin: 0;
      }
    </style>

    <script type="module">
      import * as THREE from "./three.js/build/three.module.js";

      import { OrbitControls } from "./three.js/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "./three.js/examples/jsm/loaders/GLTFLoader.js";
      import { RGBELoader } from "./three.js/examples/jsm/loaders/RGBELoader.js";
      import { ColladaLoader } from "./three.js/examples/jsm/loaders/ColladaLoader.js";
      import { RoughnessMipmapper } from "./three.js/examples/jsm/utils/RoughnessMipmapper.js";
      import { GUI } from "./three.js/examples/jsm/libs/dat.gui.module.js";

      let popup = document.getElementById("popup");
      let avatar, st, st2, st3;
      let clock, mixer, mixer2, mixer3, mixer4;
      let container, controls;
      let ambientLight, camera, scene, renderer;
      let params = {
        showHome: showHome,
        showBoiler: showBoiler,
        showFluid: showFluid,
        showPipes: showPipes,
        showWell: showWell,
        stormTroopers: false,
      };

      init();
      createGUI();
      animate();

      function showBoiler() {
        camera.position.set(19.5, 2, -1);
        controls.target.set(19.5, 2, -4);
        controls.update();
        camera.updateProjectionMatrix();

        popup.style.display = "flex";
        document.getElementById("popImg").src = "./Img/BoilerImage.jpg";
        document.getElementById("popHeader").innerHTML = "Boiler";
        document.getElementById("popText").innerHTML =
          "This isn't your average boiler. No, it's way better than that.  Like at least 10 times as good as a regular boiler!";
      }

      function showFluid() {
        camera.position.set(26, 4, 5);
        controls.target.set(22, 1, 5);
        controls.update();
        camera.updateProjectionMatrix();

        popup.style.display = "flex";
        document.getElementById("popImg").src =
          "https://i0.wp.com/tmrblog.com/wp-content/uploads/2019/12/cooling-tower-500x500.jpg?fit=500%2C412&ssl=1";
        document.getElementById("popHeader").innerHTML = "Cooling Tower";
        document.getElementById("popText").innerHTML =
          "This cools stuff I'm pretty sure!";
      }

      function showHome() {
        camera.position.set(34, 10, 12);
        controls.target.set(15, 0, 0);
        controls.update();
        camera.updateProjectionMatrix();

        popup.style.display = "none";
      }

      function showPipes() {
        camera.position.set(10, 20, 0);
        controls.target.set(10, 1, 0);
        controls.update();
        camera.updateProjectionMatrix();

        popup.style.display = "flex";
        document.getElementById("popImg").src =
          "https://media.sciencephoto.com/t1/36/00/90/t1360090-800px-wm.jpg";
        document.getElementById("popHeader").innerHTML = "Pipes";
        document.getElementById("popText").innerHTML =
          "Heat is collected throughout the water wells and dissipated into the ground. Water returns to the dorms with a lower temperature.";
      }

      function showWell() {
        camera.position.set(8, -5, 0);
        controls.target.set(0, -5, 0);
        controls.update();
        camera.updateProjectionMatrix();

        popup.style.display = "flex";
        document.getElementById("popImg").src = "./Img/Well.jpg";
        document.getElementById("popHeader").innerHTML = "Geothermal Well";
        document.getElementById("popText").innerHTML =
          "These are created by drilling a large hole down into the earth, usually at least 3 inches in diameter, until a specific depth is reached that can supply enough geothermal energy to heat and cool the facility it will be installed in. Our 220 wells are 300â€™ underneath the ground.";
      }

      var mouse, raycaster;

      function init() {
        container = document.createElement("div");
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(
          90,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(34, 10, 12);

        scene = new THREE.Scene();
        clock = new THREE.Clock();

        new RGBELoader()
          .setDataType(THREE.UnsignedByteType)
          .setPath("Img/")
          .load("Gradient.hdr", function (texture) {
            let envMap = pmremGenerator.fromEquirectangular(texture).texture;

            scene.background = envMap;
            scene.environment = envMap;

            texture.dispose();
            pmremGenerator.dispose();
            render();

            let roughnessMipmapper = new RoughnessMipmapper(renderer);


        //THIS SECTION OF CODE LOADS EACH MODEL INTO THE SCENE
            let mainLoader = new GLTFLoader().setPath("Models/");
            mainLoader.load("main.glb", function (gltf) {
              var mainModel = gltf
              mainModel.scene.traverse(function (child) {
                if (child.isMesh) {
                }
              });
              scene.add(mainModel.scene);
              roughnessMipmapper.dispose();
              render();
            });
            
            let airLoader = new GLTFLoader().setPath("Models/");
            airLoader.load("AirCooler.glb", function (gltf) {
              var airModel = gltf
              airModel.scene.traverse(function (child) {
                if (child.isMesh) {
                }
              });
              scene.add(airModel.scene);
              roughnessMipmapper.dispose();
              render();
            });

            let pipeLoader = new GLTFLoader().setPath("Models/");
            pipeLoader.load("pipes.glb", function (gltf) {
              var pipesModel = gltf
              pipesModel.scene.traverse(function (child) {
                if (child.isMesh) {
                }
              });
              scene.add(pipesModel.scene);
              roughnessMipmapper.dispose();
              render();
            });

            let pumpLoader = new GLTFLoader().setPath("Models/");
            pumpLoader.load("waterPumps.glb", function (gltf) {
              var pumpModel = gltf
              pumpModel.scene.traverse(function (child) {
                if (child.isMesh) {
                }
              });
              scene.add(pumpModel.scene);
              roughnessMipmapper.dispose();
              render();
            });

            let rmaLoader = new GLTFLoader().setPath("Models/");
            rmaLoader.load("rmas.glb", function (gltf) {
              var rmaModel = gltf
              rmaModel.scene.traverse(function (child) {
                if (child.isMesh) {
                }
              });
              scene.add(rmaModel.scene);
              roughnessMipmapper.dispose();
              render();
            });

            let cCoolerLoader = new GLTFLoader().setPath("Models/");
            cCoolerLoader.load("ceilingCoolers.glb", function (gltf) {
              var cCoolerModel = gltf
              cCoolerModel.scene.traverse(function (child) {
                if (child.isMesh) {
                }
              });
              scene.add(cCoolerModel.scene);
              roughnessMipmapper.dispose();
              render();
            });

            let wellLoader = new GLTFLoader().setPath("Models/");
            wellLoader.load("well.glb", function (gltf) {
              var wellModel = gltf
              wellModel.scene.traverse(function (child) {
                if (child.isMesh) {
                }
              });
              scene.add(wellModel.scene);
              roughnessMipmapper.dispose();
              render();
            });

            let boilerLoader = new GLTFLoader().setPath("Models/");
            boilerLoader.load("boiler.glb", function (gltf) {
              var boilerModel = gltf
              boilerModel.scene.traverse(function (child) {
                if (child.isMesh) {
                }
              });
              scene.add(boilerModel.scene);
              roughnessMipmapper.dispose();
              render();
            });
          });
        //END OF MODEL LOADING  

        //This adds in raycasting
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('touchstart',onDocumentTouchStart, false);
        //End adding raycaster

        ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.addEventListener("change", render); // use if there is no animation loop
        controls.minDistance = 2;
        controls.maxDistance = 60;
        controls.target.set(15, 0, 0);
        controls.autoRotate = true;
        controls.autoRotate = 2.0;
        controls.update();

        let pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        window.addEventListener("resize", onWindowResize, false);
      }

      function createGUI() {
        let gui = new GUI({ name: "Damp setting" });
        gui.add(params, "showHome").name("Home View");
        gui.add(params, "showBoiler").name("Boiler");
        gui.add(params, "showFluid").name("Fluid Cooler");
        gui.add(params, "showPipes").name("Pipes");
        gui.add(params, "showWell").name("Geothermal Well");
        gui
          .add(params, "stormTroopers")
          .name("Storm Troopers")
          .onChange(function (val) {
            if (val === true) {
              scene.add(avatar);
              scene.add(st);
              scene.add(st2);
              scene.add(st3);
            } else {
              scene.remove(avatar);
              scene.remove(st);
              scene.remove(st2);
              scene.remove(st3);
            }
          });
        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        render();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        render();
      }

      function onDocumentTouchStart( event ) {

        event.preventDefault();
        event.clinetX = event.touches[0].clientX;
        event.clientY = event.touches[0].clientY;
        onDocumentMouseDown(event);

      }

      function onDocumentMouseDown( event ) {

        event.preventDefault();

        mouse.x = (event.clientX / renderer.domElement.width) * 2 - 1;
        mouse.y = - (event.clientY / renderer.domElement.height) * 2 + 1;

        raycaster.setFromCamera(mouse,camera);
        var intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0){
          if(INTERSECTED != intersects[0].object){
            if (INTERSECTED == boilerModel){
              console.log("Boiler hit.");
                showBoiler();
            }
        }
      }
    }

      function render() {
        let delta = clock.getDelta();

        if (mixer !== undefined) {
          mixer.update(delta);
        }
        if (mixer2 !== undefined) {
          mixer2.update(delta);
        }
        if (mixer3 !== undefined) {
          mixer3.update(delta);
        }
        if (mixer4 !== undefined) {
          mixer4.update(delta);
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
